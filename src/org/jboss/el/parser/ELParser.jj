/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. .\ELParser.jj */
/*@egen*//*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
	Author:	Jacob Hookom
	Email:	jacob at hookom.net
*/

/* == Option Declaration == */
options
{
	JDK_VERSION="1.5";
	STATIC=false;                                                                                                                          
	JAVA_UNICODE_ESCAPE=false;
  	UNICODE_INPUT=true;                         
}

/* == Parser Declaration == */
PARSER_BEGIN( ELParser )
package org.jboss.el.parser;
import java.io.StringReader;
import javax.el.ELException;
public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTELParserState jjtree = new JJTELParserState();

/*@egen*/
    public static Node parse(String ref) throws ELException
    {
        try {
        	return (new ELParser(new StringReader(ref))).CompositeExpression();
        } catch (ParseException pe) {
           	throw new ELException(pe.getMessage(), pe);
        }
    }
}
PARSER_END( ELParser )

TOKEN_MGR_DECLS:
{
	private int subExpressionCount = 0;
}

/*
 * CompositeExpression
 * Allow most flexible parsing, restrict by examining
 * type of returned node
 */
AstCompositeExpression CompositeExpression()                      : {/*@bgen(jjtree) CompositeExpression */
  AstCompositeExpression jjtn000 = new AstCompositeExpression(JJTCOMPOSITEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CompositeExpression */
        try {
/*@egen*/
	(DeferredExpression() | DynamicExpression() | LiteralExpression())* <EOF>/*@bgen(jjtree)*/
                                                                                  {
                                                                                    jjtree.closeNodeScope(jjtn000, true);
                                                                                    jjtc000 = false;
                                                                                  }
/*@egen*/ { return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * LiteralExpression
 * Non-EL Expression blocks
 */
void LiteralExpression()                    : {/*@bgen(jjtree) LiteralExpression */
                                                AstLiteralExpression jjtn000 = new AstLiteralExpression(JJTLITERALEXPRESSION);
                                                boolean jjtc000 = true;
                                                jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) LiteralExpression */
        try {
/*@egen*/
	t=<LITERAL_EXPRESSION>/*@bgen(jjtree)*/
                               {
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                               }
/*@egen*/ { jjtn000.setImage(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * DeferredExpression
 * #{..} Expressions
 */
void DeferredExpression()                     : {/*@bgen(jjtree) DeferredExpression */
  AstDeferredExpression jjtn000 = new AstDeferredExpression(JJTDEFERREDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DeferredExpression */
        try {
/*@egen*/
	<START_DEFERRED_EXPRESSION> Expression() <RBRACE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

/*
 * DynamicExpression
 * ${..} Expressions
 */
void DynamicExpression()                    : {/*@bgen(jjtree) DynamicExpression */
  AstDynamicExpression jjtn000 = new AstDynamicExpression(JJTDYNAMICEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DynamicExpression */
        try {
/*@egen*/
	<START_DYNAMIC_EXPRESSION> Expression() <RBRACE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

/*
 * Expression
 * EL Expression Language Root, goes to Choice
 */
void Expression() : {}
{
	Choice()
}

/*
 * Choice
 * For Choice markup a ? b : c, then Or
 */
void Choice() : {}
{
	Or() (<QUESTIONMARK> Or() <COLON>/*@bgen(jjtree) #Choice( 3) */
                                          {
                                            AstChoice jjtn001 = new AstChoice(JJTCHOICE);
                                            boolean jjtc001 = true;
                                            jjtree.openNodeScope(jjtn001);
                                          }
                                          try {
/*@egen*/ Or()/*@bgen(jjtree)*/
                                          } catch (Throwable jjte001) {
                                            if (jjtc001) {
                                              jjtree.clearNodeScope(jjtn001);
                                              jjtc001 = false;
                                            } else {
                                              jjtree.popNode();
                                            }
                                            if (jjte001 instanceof RuntimeException) {
                                              throw (RuntimeException)jjte001;
                                            }
                                            if (jjte001 instanceof ParseException) {
                                              throw (ParseException)jjte001;
                                            }
                                            throw (Error)jjte001;
                                          } finally {
                                            if (jjtc001) {
                                              jjtree.closeNodeScope(jjtn001,  3);
                                            }
                                          }
/*@egen*/)*
}

/*
 * Or
 * For 'or' '||', then And
 */
void Or() : {}
{
	And() ((<OR0>|<OR1>)/*@bgen(jjtree) #Or( 2) */
                             {
                               AstOr jjtn001 = new AstOr(JJTOR);
                               boolean jjtc001 = true;
                               jjtree.openNodeScope(jjtn001);
                             }
                             try {
/*@egen*/ And()/*@bgen(jjtree)*/
                             } catch (Throwable jjte001) {
                               if (jjtc001) {
                                 jjtree.clearNodeScope(jjtn001);
                                 jjtc001 = false;
                               } else {
                                 jjtree.popNode();
                               }
                               if (jjte001 instanceof RuntimeException) {
                                 throw (RuntimeException)jjte001;
                               }
                               if (jjte001 instanceof ParseException) {
                                 throw (ParseException)jjte001;
                               }
                               throw (Error)jjte001;
                             } finally {
                               if (jjtc001) {
                                 jjtree.closeNodeScope(jjtn001,  2);
                               }
                             }
/*@egen*/)*
}

/*
 * And
 * For 'and' '&&', then Equality
 */
void And() : {}
{
	Equality() ((<AND0>|<AND1>)/*@bgen(jjtree) #And( 2) */
                                    {
                                      AstAnd jjtn001 = new AstAnd(JJTAND);
                                      boolean jjtc001 = true;
                                      jjtree.openNodeScope(jjtn001);
                                    }
                                    try {
/*@egen*/ Equality()/*@bgen(jjtree)*/
                                    } catch (Throwable jjte001) {
                                      if (jjtc001) {
                                        jjtree.clearNodeScope(jjtn001);
                                        jjtc001 = false;
                                      } else {
                                        jjtree.popNode();
                                      }
                                      if (jjte001 instanceof RuntimeException) {
                                        throw (RuntimeException)jjte001;
                                      }
                                      if (jjte001 instanceof ParseException) {
                                        throw (ParseException)jjte001;
                                      }
                                      throw (Error)jjte001;
                                    } finally {
                                      if (jjtc001) {
                                        jjtree.closeNodeScope(jjtn001,  2);
                                      }
                                    }
/*@egen*/)*
}

/*
 * Equality
 * For '==' 'eq' '!=' 'ne', then Compare
 */
void Equality() : {}
{
	Compare()
	(
		((<EQ0>|<EQ1>)/*@bgen(jjtree) #Equal( 2) */
                               {
                                 AstEqual jjtn001 = new AstEqual(JJTEQUAL);
                                 boolean jjtc001 = true;
                                 jjtree.openNodeScope(jjtn001);
                               }
                               try {
/*@egen*/ Compare()/*@bgen(jjtree)*/
                               } catch (Throwable jjte001) {
                                 if (jjtc001) {
                                   jjtree.clearNodeScope(jjtn001);
                                   jjtc001 = false;
                                 } else {
                                   jjtree.popNode();
                                 }
                                 if (jjte001 instanceof RuntimeException) {
                                   throw (RuntimeException)jjte001;
                                 }
                                 if (jjte001 instanceof ParseException) {
                                   throw (ParseException)jjte001;
                                 }
                                 throw (Error)jjte001;
                               } finally {
                                 if (jjtc001) {
                                   jjtree.closeNodeScope(jjtn001,  2);
                                 }
                               }
/*@egen*/)
	|
		((<NE0>|<NE1>)/*@bgen(jjtree) #NotEqual( 2) */
                               {
                                 AstNotEqual jjtn002 = new AstNotEqual(JJTNOTEQUAL);
                                 boolean jjtc002 = true;
                                 jjtree.openNodeScope(jjtn002);
                               }
                               try {
/*@egen*/ Compare()/*@bgen(jjtree)*/
                               } catch (Throwable jjte002) {
                                 if (jjtc002) {
                                   jjtree.clearNodeScope(jjtn002);
                                   jjtc002 = false;
                                 } else {
                                   jjtree.popNode();
                                 }
                                 if (jjte002 instanceof RuntimeException) {
                                   throw (RuntimeException)jjte002;
                                 }
                                 if (jjte002 instanceof ParseException) {
                                   throw (ParseException)jjte002;
                                 }
                                 throw (Error)jjte002;
                               } finally {
                                 if (jjtc002) {
                                   jjtree.closeNodeScope(jjtn002,  2);
                                 }
                               }
/*@egen*/)
	)*
}

/*
 * Compare
 * For a bunch of them, then Math
 */
void Compare() : {}
{
	Math()
	(
		((<LT0>|<LT1>)/*@bgen(jjtree) #LessThan( 2) */
                               {
                                 AstLessThan jjtn001 = new AstLessThan(JJTLESSTHAN);
                                 boolean jjtc001 = true;
                                 jjtree.openNodeScope(jjtn001);
                               }
                               try {
/*@egen*/ Math()/*@bgen(jjtree)*/
                               } catch (Throwable jjte001) {
                                 if (jjtc001) {
                                   jjtree.clearNodeScope(jjtn001);
                                   jjtc001 = false;
                                 } else {
                                   jjtree.popNode();
                                 }
                                 if (jjte001 instanceof RuntimeException) {
                                   throw (RuntimeException)jjte001;
                                 }
                                 if (jjte001 instanceof ParseException) {
                                   throw (ParseException)jjte001;
                                 }
                                 throw (Error)jjte001;
                               } finally {
                                 if (jjtc001) {
                                   jjtree.closeNodeScope(jjtn001,  2);
                                 }
                               }
/*@egen*/)
	|
		((<GT0>|<GT1>)/*@bgen(jjtree) #GreaterThan( 2) */
                               {
                                 AstGreaterThan jjtn002 = new AstGreaterThan(JJTGREATERTHAN);
                                 boolean jjtc002 = true;
                                 jjtree.openNodeScope(jjtn002);
                               }
                               try {
/*@egen*/ Math()/*@bgen(jjtree)*/
                               } catch (Throwable jjte002) {
                                 if (jjtc002) {
                                   jjtree.clearNodeScope(jjtn002);
                                   jjtc002 = false;
                                 } else {
                                   jjtree.popNode();
                                 }
                                 if (jjte002 instanceof RuntimeException) {
                                   throw (RuntimeException)jjte002;
                                 }
                                 if (jjte002 instanceof ParseException) {
                                   throw (ParseException)jjte002;
                                 }
                                 throw (Error)jjte002;
                               } finally {
                                 if (jjtc002) {
                                   jjtree.closeNodeScope(jjtn002,  2);
                                 }
                               }
/*@egen*/)
	|
		((<LE0>|<LE1>)/*@bgen(jjtree) #LessThanEqual( 2) */
                               {
                                 AstLessThanEqual jjtn003 = new AstLessThanEqual(JJTLESSTHANEQUAL);
                                 boolean jjtc003 = true;
                                 jjtree.openNodeScope(jjtn003);
                               }
                               try {
/*@egen*/ Math()/*@bgen(jjtree)*/
                               } catch (Throwable jjte003) {
                                 if (jjtc003) {
                                   jjtree.clearNodeScope(jjtn003);
                                   jjtc003 = false;
                                 } else {
                                   jjtree.popNode();
                                 }
                                 if (jjte003 instanceof RuntimeException) {
                                   throw (RuntimeException)jjte003;
                                 }
                                 if (jjte003 instanceof ParseException) {
                                   throw (ParseException)jjte003;
                                 }
                                 throw (Error)jjte003;
                               } finally {
                                 if (jjtc003) {
                                   jjtree.closeNodeScope(jjtn003,  2);
                                 }
                               }
/*@egen*/)
	|
		((<GE0>|<GE1>)/*@bgen(jjtree) #GreaterThanEqual( 2) */
                               {
                                 AstGreaterThanEqual jjtn004 = new AstGreaterThanEqual(JJTGREATERTHANEQUAL);
                                 boolean jjtc004 = true;
                                 jjtree.openNodeScope(jjtn004);
                               }
                               try {
/*@egen*/ Math()/*@bgen(jjtree)*/
                               } catch (Throwable jjte004) {
                                 if (jjtc004) {
                                   jjtree.clearNodeScope(jjtn004);
                                   jjtc004 = false;
                                 } else {
                                   jjtree.popNode();
                                 }
                                 if (jjte004 instanceof RuntimeException) {
                                   throw (RuntimeException)jjte004;
                                 }
                                 if (jjte004 instanceof ParseException) {
                                   throw (ParseException)jjte004;
                                 }
                                 throw (Error)jjte004;
                               } finally {
                                 if (jjtc004) {
                                   jjtree.closeNodeScope(jjtn004,  2);
                                 }
                               }
/*@egen*/)
	)*
}

/*
 * Math
 * For '+' '-', then Multiplication
 */
void Math() : {}
{
	Multiplication()
	(
		(<PLUS>/*@bgen(jjtree) #Plus( 2) */
                        {
                          AstPlus jjtn001 = new AstPlus(JJTPLUS);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                        }
                        try {
/*@egen*/ Multiplication()/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  2);
                          }
                        }
/*@egen*/)
	|
		(<MINUS>/*@bgen(jjtree) #Minus( 2) */
                         {
                           AstMinus jjtn002 = new AstMinus(JJTMINUS);
                           boolean jjtc002 = true;
                           jjtree.openNodeScope(jjtn002);
                         }
                         try {
/*@egen*/ Multiplication()/*@bgen(jjtree)*/
                         } catch (Throwable jjte002) {
                           if (jjtc002) {
                             jjtree.clearNodeScope(jjtn002);
                             jjtc002 = false;
                           } else {
                             jjtree.popNode();
                           }
                           if (jjte002 instanceof RuntimeException) {
                             throw (RuntimeException)jjte002;
                           }
                           if (jjte002 instanceof ParseException) {
                             throw (ParseException)jjte002;
                           }
                           throw (Error)jjte002;
                         } finally {
                           if (jjtc002) {
                             jjtree.closeNodeScope(jjtn002,  2);
                           }
                         }
/*@egen*/)
	)*
}

/*
 * Multiplication
 * For a bunch of them, then Unary
 */
void Multiplication() : {}
{
	Unary()
	(
		(<MULT>/*@bgen(jjtree) #Mult( 2) */
                        {
                          AstMult jjtn001 = new AstMult(JJTMULT);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                        }
                        try {
/*@egen*/ Unary()/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  2);
                          }
                        }
/*@egen*/)
	|
		((<DIV0>|<DIV1>)/*@bgen(jjtree) #Div( 2) */
                                 {
                                   AstDiv jjtn002 = new AstDiv(JJTDIV);
                                   boolean jjtc002 = true;
                                   jjtree.openNodeScope(jjtn002);
                                 }
                                 try {
/*@egen*/ Unary()/*@bgen(jjtree)*/
                                 } catch (Throwable jjte002) {
                                   if (jjtc002) {
                                     jjtree.clearNodeScope(jjtn002);
                                     jjtc002 = false;
                                   } else {
                                     jjtree.popNode();
                                   }
                                   if (jjte002 instanceof RuntimeException) {
                                     throw (RuntimeException)jjte002;
                                   }
                                   if (jjte002 instanceof ParseException) {
                                     throw (ParseException)jjte002;
                                   }
                                   throw (Error)jjte002;
                                 } finally {
                                   if (jjtc002) {
                                     jjtree.closeNodeScope(jjtn002,  2);
                                   }
                                 }
/*@egen*/)
	|
		((<MOD0>|<MOD1>)/*@bgen(jjtree) #Mod( 2) */
                                 {
                                   AstMod jjtn003 = new AstMod(JJTMOD);
                                   boolean jjtc003 = true;
                                   jjtree.openNodeScope(jjtn003);
                                 }
                                 try {
/*@egen*/ Unary()/*@bgen(jjtree)*/
                                 } catch (Throwable jjte003) {
                                   if (jjtc003) {
                                     jjtree.clearNodeScope(jjtn003);
                                     jjtc003 = false;
                                   } else {
                                     jjtree.popNode();
                                   }
                                   if (jjte003 instanceof RuntimeException) {
                                     throw (RuntimeException)jjte003;
                                   }
                                   if (jjte003 instanceof ParseException) {
                                     throw (ParseException)jjte003;
                                   }
                                   throw (Error)jjte003;
                                 } finally {
                                   if (jjtc003) {
                                     jjtree.closeNodeScope(jjtn003,  2);
                                   }
                                 }
/*@egen*/)	
	)*	
}

/*
 * Unary
 * For '-' '!' 'not' 'empty', then Value
 */
void Unary() : {}
{
		<MINUS>/*@bgen(jjtree) Negative */
                        {
                          AstNegative jjtn001 = new AstNegative(JJTNEGATIVE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                        }
                        try {
/*@egen*/ Unary()/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, true);
                          }
                        }
/*@egen*/ 
	|
		(<NOT0>|<NOT1>)/*@bgen(jjtree) Not */
                                {
                                  AstNot jjtn002 = new AstNot(JJTNOT);
                                  boolean jjtc002 = true;
                                  jjtree.openNodeScope(jjtn002);
                                }
                                try {
/*@egen*/ Unary()/*@bgen(jjtree)*/
                                } catch (Throwable jjte002) {
                                  if (jjtc002) {
                                    jjtree.clearNodeScope(jjtn002);
                                    jjtc002 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte002 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte002;
                                  }
                                  if (jjte002 instanceof ParseException) {
                                    throw (ParseException)jjte002;
                                  }
                                  throw (Error)jjte002;
                                } finally {
                                  if (jjtc002) {
                                    jjtree.closeNodeScope(jjtn002, true);
                                  }
                                }
/*@egen*/ 
	|
		<EMPTY>/*@bgen(jjtree) Empty */
                        {
                          AstEmpty jjtn003 = new AstEmpty(JJTEMPTY);
                          boolean jjtc003 = true;
                          jjtree.openNodeScope(jjtn003);
                        }
                        try {
/*@egen*/ Unary()/*@bgen(jjtree)*/
                        } catch (Throwable jjte003) {
                          if (jjtc003) {
                            jjtree.clearNodeScope(jjtn003);
                            jjtc003 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte003 instanceof RuntimeException) {
                            throw (RuntimeException)jjte003;
                          }
                          if (jjte003 instanceof ParseException) {
                            throw (ParseException)jjte003;
                          }
                          throw (Error)jjte003;
                        } finally {
                          if (jjtc003) {
                            jjtree.closeNodeScope(jjtn003, true);
                          }
                        }
/*@egen*/
	|	
		Value()
}

/*
 * Value
 * Defines Prefix plus zero or more Suffixes
 */
void Value() : {}
{/*@bgen(jjtree) #Value(> 1) */
        {
          AstValue jjtn001 = new AstValue(JJTVALUE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(ValuePrefix()
            (DotSuffix() | BracketSuffix())*
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

/*
 * ValuePrefix
 * For Literals, Variables, and Functions
 */
void ValuePrefix() : {}
{
	Literal() | NonLiteral()
}

/*
 * DotSuffix
 * Dot Property
 */
void DotSuffix() : {}
{
	<DOT> (
			LOOKAHEAD(2) MethodSuffix()
		|
			LOOKAHEAD(2) PropertySuffix()
                |
                        LOOKAHEAD(2) ClosureSuffix()
	)
}

/*
 * PropertySuffix
 * Dot Property
 */
void PropertySuffix()                 : {/*@bgen(jjtree) PropertySuffix */
                                          AstPropertySuffix jjtn000 = new AstPropertySuffix(JJTPROPERTYSUFFIX);
                                          boolean jjtc000 = true;
                                          jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) PropertySuffix */
        try {
/*@egen*/
        t=<IDENTIFIER>/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                       }
/*@egen*/ { jjtn000.setImage(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * BracketSuffix
 * Sub Expression Suffix
 */
void BracketSuffix()                : {/*@bgen(jjtree) BracketSuffix */
  AstBracketSuffix jjtn000 = new AstBracketSuffix(JJTBRACKETSUFFIX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BracketSuffix */
        try {
/*@egen*/
	<LBRACK> Expression() <RBRACK>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * MethodSuffix
 * Method Suffix
 */
void MethodSuffix()               : {/*@bgen(jjtree) MethodSuffix */
                                      AstMethodSuffix jjtn000 = new AstMethodSuffix(JJTMETHODSUFFIX);
                                      boolean jjtc000 = true;
                                      jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) MethodSuffix */
        try {
/*@egen*/
	t=<IDENTIFIER> { jjtn000.setImage(t.image); }
	<LPAREN> (Expression() (<COMMA> Expression())*)? <RPAREN>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ClosureSuffix()                : {/*@bgen(jjtree) ClosureSuffix */
                                        AstClosureSuffix jjtn000 = new AstClosureSuffix(JJTCLOSURESUFFIX);
                                        boolean jjtc000 = true;
                                        jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) ClosureSuffix */
        try {
/*@egen*/
	[t=<IDENTIFIER> { jjtn000.setImage(t.image); }]
	Closure()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Closure()          : {/*@bgen(jjtree) Closure */
                            AstClosure jjtn000 = new AstClosure(JJTCLOSURE);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) Closure */
        try {
/*@egen*/
	<LBRACE>
	t = <IDENTIFIER> { jjtn000.setImage(t.image); }
	<PIPE>
	Expression()
	<RBRACE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * NonLiteral
 * For Grouped Operations, Identifiers, and Functions
 */
void NonLiteral() : {}
{
 	<LPAREN> Expression() <RPAREN>
 	| LOOKAHEAD(3) Function()
	| Identifier()
}

/*
 * Identifier
 * Java Language Identifier
 */
void Identifier()             : {/*@bgen(jjtree) Identifier */
                                  AstIdentifier jjtn000 = new AstIdentifier(JJTIDENTIFIER);
                                  boolean jjtc000 = true;
                                  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) Identifier */
        try {
/*@egen*/
	t=<IDENTIFIER>/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                       }
/*@egen*/ { jjtn000.setImage(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * Function
 * Namespace:Name(a,b,c)
 */
void Function()           :
{/*@bgen(jjtree) Function */
        AstFunction jjtn000 = new AstFunction(JJTFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t0 = null;
	Token t1 = null;
}
{/*@bgen(jjtree) Function */
        try {
/*@egen*/
	(t0=<NAMESPACE>)? t1=<IDENTIFIER>
	{
		if (t0 != null) {
			jjtn000.setPrefix(t0.image.substring(0, t0.image.length() - 1));
			jjtn000.setLocalName(t1.image);
		} else {
			jjtn000.setLocalName(t1.image);
		}
	}
	<LPAREN> (Expression() (<COMMA> Expression())*)? <RPAREN>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * Literal
 * Reserved Keywords
 */
void Literal() : {}
{
	Boolean()
	| FloatingPoint()
	| Integer()
	| String()
	| Null()
}

/*
 * Boolean
 * For 'true' 'false'
 */
void Boolean() : {}
{/*@bgen(jjtree) True */
        {
          AstTrue jjtn001 = new AstTrue(JJTTRUE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	<TRUE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/
	|/*@bgen(jjtree) False */
          {
            AstFalse jjtn002 = new AstFalse(JJTFALSE);
            boolean jjtc002 = true;
            jjtree.openNodeScope(jjtn002);
          }
          try {
/*@egen*/ <FALSE>/*@bgen(jjtree)*/
          } finally {
            if (jjtc002) {
              jjtree.closeNodeScope(jjtn002, true);
            }
          }
/*@egen*/
}

/*
 * FloatinPoint
 * For Decimal and Floating Point Literals
 */
void FloatingPoint()                : {/*@bgen(jjtree) FloatingPoint */
                                        AstFloatingPoint jjtn000 = new AstFloatingPoint(JJTFLOATINGPOINT);
                                        boolean jjtc000 = true;
                                        jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) FloatingPoint */
        try {
/*@egen*/
	t=<FLOATING_POINT_LITERAL>/*@bgen(jjtree)*/
                                   {
                                     jjtree.closeNodeScope(jjtn000, true);
                                     jjtc000 = false;
                                   }
/*@egen*/ { jjtn000.setImage(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * Integer
 * For Simple Numeric Literals
 */
void Integer()          : {/*@bgen(jjtree) Integer */
                            AstInteger jjtn000 = new AstInteger(JJTINTEGER);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) Integer */
        try {
/*@egen*/
	t=<INTEGER_LITERAL>/*@bgen(jjtree)*/
                            {
                              jjtree.closeNodeScope(jjtn000, true);
                              jjtc000 = false;
                            }
/*@egen*/ { jjtn000.setImage(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * String
 * For Quoted Literals
 */
void String()         : {/*@bgen(jjtree) String */
                          AstString jjtn000 = new AstString(JJTSTRING);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) String */
        try {
/*@egen*/
	t=<STRING_LITERAL>/*@bgen(jjtree)*/
                           {
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                           }
/*@egen*/ { jjtn000.setImage(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * Null
 * For 'null'
 */
void Null()       : {/*@bgen(jjtree) Null */
  AstNull jjtn000 = new AstNull(JJTNULL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Null */
        try {
/*@egen*/
	<NULL>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/* ==================================================================================== */
<DEFAULT> TOKEN :
{
  < LITERAL_EXPRESSION:
    ((~["\\", "$", "#"])
      | ("\\" ("\\" | "$" | "#"))
      | ("$" ~["{", "$"])
      | ("#" ~["{", "#"])
    )+
    | "$"
    | "#"
  >
|
  < START_DYNAMIC_EXPRESSION: "${" > : IN_EXPRESSION
|
  < START_DEFERRED_EXPRESSION: "#{" > : IN_EXPRESSION
}

<DEFAULT> SKIP : { "\\" }

<IN_EXPRESSION> SKIP : { " " | "\t" | "\n" | "\r" }

<IN_EXPRESSION> TOKEN :
{
	< INTEGER_LITERAL: ["0"-"9"] (["0"-"9"])* >
|	< FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? 
		| "." (["0"-"9"])+ (<EXPONENT>)?
		| (["0"-"9"])+ <EXPONENT>
	>
|	< #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|	< STRING_LITERAL: ("\"" ((~["\"","\\"])
		| ("\\" ( ["\\","\""] )))* "\"")
		| ("\'" ((~["\'","\\"])
		| ("\\" ( ["\\","\'"] )))* "\'")
	>
|	< BADLY_ESCAPED_STRING_LITERAL: ("\"" (~["\"","\\"])* ("\\" ( ~["\\","\""] )))
		| ("\'" (~["\'","\\"])* ("\\" ( ~["\\","\'"] )))
	>
|	< TRUE : "true" >
|	< FALSE : "false" >
|	< NULL : "null" >
|	< DOT : "." >
|	< AT : "@" >
|	< LBRACE : "{" > { this.subExpressionCount++; }
|	< RBRACE : "}" > { if (--this.subExpressionCount < 0) SwitchTo(DEFAULT); }
|	< PIPE   : "|" >
|	< LPAREN : "(" >
|	< RPAREN : ")" >
|	< LBRACK : "[" >
|	< RBRACK : "]" >
|	< COLON : ":" >
|	< COMMA : "," >
|	< GT0 : ">" >
|	< GT1 : "gt" >
|	< LT0 : "<" >
|	< LT1 : "lt" >
|	< GE0 : ">=" >
|	< GE1 : "ge" >
|	< LE0 : "<=" >
|	< LE1 : "le" >
|	< EQ0 : "==" >
|	< EQ1 : "eq" >
|	< NE0 : "!=" >
|	< NE1 : "ne" >
|	< NOT0 : "!" >
|	< NOT1 : "not" >
|	< AND0 : "&&" >
|	< AND1 : "and" >
|	< OR0 : "||" >
|	< OR1 : "or" >
|	< EMPTY : "empty" >
|	< INSTANCEOF : "instanceof" >
|	< MULT : "*" >
|	< PLUS : "+" >
|	< MINUS : "-" >
|	< QUESTIONMARK : "?" >
|	< DIV0 : "/" >
|	< DIV1 : "div" >
|	< MOD0 : "%" >
|	< MOD1 : "mod" >
|	< IDENTIFIER : (<LETTER>|<IMPL_OBJ_START>) (<LETTER>|<DIGIT>)* >
|       < NAMESPACE : (<IDENTIFIER> (<IDENTIFIER>|<MINUS>|<DOT>)* <COLON>) >
|	< FUNCTIONSUFFIX : (<IDENTIFIER>) >
|	< #IMPL_OBJ_START: "#" >
|	< #LETTER:
		[
		"$",
		"A"-"Z",
		"_",
		"a"-"z",
		"\u00c0"-"\u00d6",
		"\u00d8"-"\u00f6",
		"\u00f8"-"\u00ff",
		"\u0100"-"\u1fff",
		"\u3040"-"\u318f",
		"\u3300"-"\u337f",
		"\u3400"-"\u3d2d",
		"\u4e00"-"\u9fff",
		"\uf900"-"\ufaff"
		]
	>
|	< #DIGIT:
		[
		"0"-"9",
		"\u0660"-"\u0669",
		"\u06f0"-"\u06f9",
		"\u0966"-"\u096f",
		"\u09e6"-"\u09ef",
		"\u0a66"-"\u0a6f",
		"\u0ae6"-"\u0aef",
		"\u0b66"-"\u0b6f",
		"\u0be7"-"\u0bef",
		"\u0c66"-"\u0c6f",
		"\u0ce6"-"\u0cef",
		"\u0d66"-"\u0d6f",
		"\u0e50"-"\u0e59",
		"\u0ed0"-"\u0ed9",
		"\u1040"-"\u1049"
		]
	>
|	< ILLEGAL_CHARACTER: (~[]) >
}